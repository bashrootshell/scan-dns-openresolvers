#!/usr/bin/env python3

from sys import argv, exit as callexit
from time import time
from ipaddress import ip_network
from random import shuffle
import socket as sk

"""
    --- Python DNS Open Resolver Scanner ---
    Originally written in 2013 in Python2. Refactored in 2021 with Python3.
    It still uses Pure Python and the Low-level Python networking interface.

    PEP8 compliant
    “Readability counts."
    “Beautiful is better than ugly.”
    — The Zen of Python
"""

''' set packet to use a BSD Socket UDP datagram '''

payloadhex = 'ff0001000001000000000000016c0c726f6f\
              742d73657276657273036e65740000010001'  # "l.root-servers.net"

iplist = []  # list to be used later by packet.sendto

''' check: if there's an argument and IP address is larger than /32 '''

try:
    #  this try:except structure will certify the IP Address format is valid
    if len(argv) == 1:
        callexit("Provide a single host IP Address or an IP/CIDR as argument.")
    elif ip_network(argv[1]).num_addresses > 1:
        # list comprehension to get all hosts
        iplist = [ipaddr for ipaddr in ip_network(argv[1]).hosts()]
        shuffle(iplist)
    else:
        if '/32' in argv[1]:  # ex: 8.8.8.8/32 will become '8.8.8.8'
            iplist.append(argv[1].split('/')[0])
        else:
            iplist.append(argv[1])

except ValueError as error:
    print(f'Error >>> {error}')

for host in iplist:

    try:

        with sk.socket(sk.AF_INET, sk.SOCK_DGRAM) as packet:

            packet.settimeout(0.100)

            ''' send the 'payloadhex' to hosts in the list (port 53 (DNS)) '''

            packet.sendto(bytes.fromhex(payloadhex), (str(host), int(53)))
            response = packet.recv(128)

            ''' check if response contains a valid DNS response with
                l.root-servers.net's IP address 199.7.83.42  '''

            if (b'\xc0\x0c\x00\x01\x00\x01' and
                    b'\x00\x04\xc7\x07') in response:
                unixtime = int(time())
                print(f'{host},open,{unixtime}')

    except sk.timeout:   # timeout generated by network conditions
        continue

    except ValueError as error:
        print(f'Error >>> {error}')

    except KeyboardInterrupt:
        callexit('Program execution interrupted.')
